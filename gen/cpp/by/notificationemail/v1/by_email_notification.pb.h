// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: by/notificationemail/v1/by_email_notification.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_by_2fnotificationemail_2fv1_2fby_5femail_5fnotification_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_by_2fnotificationemail_2fv1_2fby_5femail_5fnotification_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_by_2fnotificationemail_2fv1_2fby_5femail_5fnotification_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_by_2fnotificationemail_2fv1_2fby_5femail_5fnotification_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_by_2fnotificationemail_2fv1_2fby_5femail_5fnotification_2eproto;
namespace by {
namespace notificationemail {
namespace v1 {
class EmailData;
struct EmailDataDefaultTypeInternal;
extern EmailDataDefaultTypeInternal _EmailData_default_instance_;
class EmailStruct;
struct EmailStructDefaultTypeInternal;
extern EmailStructDefaultTypeInternal _EmailStruct_default_instance_;
class SendEmailInfoResponse;
struct SendEmailInfoResponseDefaultTypeInternal;
extern SendEmailInfoResponseDefaultTypeInternal _SendEmailInfoResponse_default_instance_;
class SendEmailRequest;
struct SendEmailRequestDefaultTypeInternal;
extern SendEmailRequestDefaultTypeInternal _SendEmailRequest_default_instance_;
class SendEmailResponse;
struct SendEmailResponseDefaultTypeInternal;
extern SendEmailResponseDefaultTypeInternal _SendEmailResponse_default_instance_;
}  // namespace v1
}  // namespace notificationemail
}  // namespace by
PROTOBUF_NAMESPACE_OPEN
template<> ::by::notificationemail::v1::EmailData* Arena::CreateMaybeMessage<::by::notificationemail::v1::EmailData>(Arena*);
template<> ::by::notificationemail::v1::EmailStruct* Arena::CreateMaybeMessage<::by::notificationemail::v1::EmailStruct>(Arena*);
template<> ::by::notificationemail::v1::SendEmailInfoResponse* Arena::CreateMaybeMessage<::by::notificationemail::v1::SendEmailInfoResponse>(Arena*);
template<> ::by::notificationemail::v1::SendEmailRequest* Arena::CreateMaybeMessage<::by::notificationemail::v1::SendEmailRequest>(Arena*);
template<> ::by::notificationemail::v1::SendEmailResponse* Arena::CreateMaybeMessage<::by::notificationemail::v1::SendEmailResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace by {
namespace notificationemail {
namespace v1 {

// ===================================================================

class EmailStruct final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:by.notificationemail.v1.EmailStruct) */ {
 public:
  inline EmailStruct() : EmailStruct(nullptr) {}
  ~EmailStruct() override;
  explicit constexpr EmailStruct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmailStruct(const EmailStruct& from);
  EmailStruct(EmailStruct&& from) noexcept
    : EmailStruct() {
    *this = ::std::move(from);
  }

  inline EmailStruct& operator=(const EmailStruct& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmailStruct& operator=(EmailStruct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmailStruct& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmailStruct* internal_default_instance() {
    return reinterpret_cast<const EmailStruct*>(
               &_EmailStruct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EmailStruct& a, EmailStruct& b) {
    a.Swap(&b);
  }
  inline void Swap(EmailStruct* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmailStruct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmailStruct* New() const final {
    return new EmailStruct();
  }

  EmailStruct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmailStruct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmailStruct& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EmailStruct& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmailStruct* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "by.notificationemail.v1.EmailStruct";
  }
  protected:
  explicit EmailStruct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEmailFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_MUST_USE_RESULT std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:by.notificationemail.v1.EmailStruct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_by_2fnotificationemail_2fv1_2fby_5femail_5fnotification_2eproto;
};
// -------------------------------------------------------------------

class EmailData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:by.notificationemail.v1.EmailData) */ {
 public:
  inline EmailData() : EmailData(nullptr) {}
  ~EmailData() override;
  explicit constexpr EmailData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmailData(const EmailData& from);
  EmailData(EmailData&& from) noexcept
    : EmailData() {
    *this = ::std::move(from);
  }

  inline EmailData& operator=(const EmailData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmailData& operator=(EmailData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmailData& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmailData* internal_default_instance() {
    return reinterpret_cast<const EmailData*>(
               &_EmailData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EmailData& a, EmailData& b) {
    a.Swap(&b);
  }
  inline void Swap(EmailData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmailData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmailData* New() const final {
    return new EmailData();
  }

  EmailData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmailData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmailData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EmailData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmailData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "by.notificationemail.v1.EmailData";
  }
  protected:
  explicit EmailData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 1,
    kCcFieldNumber = 2,
    kBbcFieldNumber = 3,
    kReplyToFieldNumber = 4,
    kSubjectFieldNumber = 5,
    kTagFieldNumber = 6,
    kTextFieldNumber = 7,
    kHtmlFieldNumber = 8,
  };
  // repeated .by.notificationemail.v1.EmailStruct to = 1 [json_name = "to"];
  int to_size() const;
  private:
  int _internal_to_size() const;
  public:
  void clear_to();
  ::by::notificationemail::v1::EmailStruct* mutable_to(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >*
      mutable_to();
  private:
  const ::by::notificationemail::v1::EmailStruct& _internal_to(int index) const;
  ::by::notificationemail::v1::EmailStruct* _internal_add_to();
  public:
  const ::by::notificationemail::v1::EmailStruct& to(int index) const;
  ::by::notificationemail::v1::EmailStruct* add_to();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >&
      to() const;

  // repeated .by.notificationemail.v1.EmailStruct cc = 2 [json_name = "cc"];
  int cc_size() const;
  private:
  int _internal_cc_size() const;
  public:
  void clear_cc();
  ::by::notificationemail::v1::EmailStruct* mutable_cc(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >*
      mutable_cc();
  private:
  const ::by::notificationemail::v1::EmailStruct& _internal_cc(int index) const;
  ::by::notificationemail::v1::EmailStruct* _internal_add_cc();
  public:
  const ::by::notificationemail::v1::EmailStruct& cc(int index) const;
  ::by::notificationemail::v1::EmailStruct* add_cc();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >&
      cc() const;

  // repeated .by.notificationemail.v1.EmailStruct bbc = 3 [json_name = "bbc"];
  int bbc_size() const;
  private:
  int _internal_bbc_size() const;
  public:
  void clear_bbc();
  ::by::notificationemail::v1::EmailStruct* mutable_bbc(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >*
      mutable_bbc();
  private:
  const ::by::notificationemail::v1::EmailStruct& _internal_bbc(int index) const;
  ::by::notificationemail::v1::EmailStruct* _internal_add_bbc();
  public:
  const ::by::notificationemail::v1::EmailStruct& bbc(int index) const;
  ::by::notificationemail::v1::EmailStruct* add_bbc();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >&
      bbc() const;

  // repeated .by.notificationemail.v1.EmailStruct reply_to = 4 [json_name = "replyTo"];
  int reply_to_size() const;
  private:
  int _internal_reply_to_size() const;
  public:
  void clear_reply_to();
  ::by::notificationemail::v1::EmailStruct* mutable_reply_to(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >*
      mutable_reply_to();
  private:
  const ::by::notificationemail::v1::EmailStruct& _internal_reply_to(int index) const;
  ::by::notificationemail::v1::EmailStruct* _internal_add_reply_to();
  public:
  const ::by::notificationemail::v1::EmailStruct& reply_to(int index) const;
  ::by::notificationemail::v1::EmailStruct* add_reply_to();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >&
      reply_to() const;

  // string subject = 5 [json_name = "subject"];
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_MUST_USE_RESULT std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // string tag = 6 [json_name = "tag"];
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // string text = 7 [json_name = "text"];
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_MUST_USE_RESULT std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string html = 8 [json_name = "html"];
  void clear_html();
  const std::string& html() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_html(ArgT0&& arg0, ArgT... args);
  std::string* mutable_html();
  PROTOBUF_MUST_USE_RESULT std::string* release_html();
  void set_allocated_html(std::string* html);
  private:
  const std::string& _internal_html() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_html(const std::string& value);
  std::string* _internal_mutable_html();
  public:

  // @@protoc_insertion_point(class_scope:by.notificationemail.v1.EmailData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct > to_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct > cc_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct > bbc_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct > reply_to_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr html_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_by_2fnotificationemail_2fv1_2fby_5femail_5fnotification_2eproto;
};
// -------------------------------------------------------------------

class SendEmailRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:by.notificationemail.v1.SendEmailRequest) */ {
 public:
  inline SendEmailRequest() : SendEmailRequest(nullptr) {}
  ~SendEmailRequest() override;
  explicit constexpr SendEmailRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendEmailRequest(const SendEmailRequest& from);
  SendEmailRequest(SendEmailRequest&& from) noexcept
    : SendEmailRequest() {
    *this = ::std::move(from);
  }

  inline SendEmailRequest& operator=(const SendEmailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendEmailRequest& operator=(SendEmailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendEmailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendEmailRequest* internal_default_instance() {
    return reinterpret_cast<const SendEmailRequest*>(
               &_SendEmailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SendEmailRequest& a, SendEmailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendEmailRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendEmailRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SendEmailRequest* New() const final {
    return new SendEmailRequest();
  }

  SendEmailRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendEmailRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendEmailRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendEmailRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendEmailRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "by.notificationemail.v1.SendEmailRequest";
  }
  protected:
  explicit SendEmailRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailDataFieldNumber = 1,
  };
  // .by.notificationemail.v1.EmailData email_data = 1 [json_name = "emailData"];
  bool has_email_data() const;
  private:
  bool _internal_has_email_data() const;
  public:
  void clear_email_data();
  const ::by::notificationemail::v1::EmailData& email_data() const;
  PROTOBUF_MUST_USE_RESULT ::by::notificationemail::v1::EmailData* release_email_data();
  ::by::notificationemail::v1::EmailData* mutable_email_data();
  void set_allocated_email_data(::by::notificationemail::v1::EmailData* email_data);
  private:
  const ::by::notificationemail::v1::EmailData& _internal_email_data() const;
  ::by::notificationemail::v1::EmailData* _internal_mutable_email_data();
  public:
  void unsafe_arena_set_allocated_email_data(
      ::by::notificationemail::v1::EmailData* email_data);
  ::by::notificationemail::v1::EmailData* unsafe_arena_release_email_data();

  // @@protoc_insertion_point(class_scope:by.notificationemail.v1.SendEmailRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::by::notificationemail::v1::EmailData* email_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_by_2fnotificationemail_2fv1_2fby_5femail_5fnotification_2eproto;
};
// -------------------------------------------------------------------

class SendEmailInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:by.notificationemail.v1.SendEmailInfoResponse) */ {
 public:
  inline SendEmailInfoResponse() : SendEmailInfoResponse(nullptr) {}
  ~SendEmailInfoResponse() override;
  explicit constexpr SendEmailInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendEmailInfoResponse(const SendEmailInfoResponse& from);
  SendEmailInfoResponse(SendEmailInfoResponse&& from) noexcept
    : SendEmailInfoResponse() {
    *this = ::std::move(from);
  }

  inline SendEmailInfoResponse& operator=(const SendEmailInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendEmailInfoResponse& operator=(SendEmailInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendEmailInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendEmailInfoResponse* internal_default_instance() {
    return reinterpret_cast<const SendEmailInfoResponse*>(
               &_SendEmailInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SendEmailInfoResponse& a, SendEmailInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendEmailInfoResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendEmailInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SendEmailInfoResponse* New() const final {
    return new SendEmailInfoResponse();
  }

  SendEmailInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendEmailInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendEmailInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendEmailInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendEmailInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "by.notificationemail.v1.SendEmailInfoResponse";
  }
  protected:
  explicit SendEmailInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSendFieldNumber = 1,
  };
  // bool send = 1 [json_name = "send"];
  void clear_send();
  bool send() const;
  void set_send(bool value);
  private:
  bool _internal_send() const;
  void _internal_set_send(bool value);
  public:

  // @@protoc_insertion_point(class_scope:by.notificationemail.v1.SendEmailInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool send_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_by_2fnotificationemail_2fv1_2fby_5femail_5fnotification_2eproto;
};
// -------------------------------------------------------------------

class SendEmailResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:by.notificationemail.v1.SendEmailResponse) */ {
 public:
  inline SendEmailResponse() : SendEmailResponse(nullptr) {}
  ~SendEmailResponse() override;
  explicit constexpr SendEmailResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendEmailResponse(const SendEmailResponse& from);
  SendEmailResponse(SendEmailResponse&& from) noexcept
    : SendEmailResponse() {
    *this = ::std::move(from);
  }

  inline SendEmailResponse& operator=(const SendEmailResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendEmailResponse& operator=(SendEmailResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendEmailResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendEmailResponse* internal_default_instance() {
    return reinterpret_cast<const SendEmailResponse*>(
               &_SendEmailResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SendEmailResponse& a, SendEmailResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendEmailResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendEmailResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SendEmailResponse* New() const final {
    return new SendEmailResponse();
  }

  SendEmailResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendEmailResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendEmailResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendEmailResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendEmailResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "by.notificationemail.v1.SendEmailResponse";
  }
  protected:
  explicit SendEmailResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kMessageFieldNumber = 2,
    kErrorFieldNumber = 4,
    kInfoFieldNumber = 3,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string message = 2 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string error = 4 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .by.notificationemail.v1.SendEmailInfoResponse info = 3 [json_name = "info"];
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::by::notificationemail::v1::SendEmailInfoResponse& info() const;
  PROTOBUF_MUST_USE_RESULT ::by::notificationemail::v1::SendEmailInfoResponse* release_info();
  ::by::notificationemail::v1::SendEmailInfoResponse* mutable_info();
  void set_allocated_info(::by::notificationemail::v1::SendEmailInfoResponse* info);
  private:
  const ::by::notificationemail::v1::SendEmailInfoResponse& _internal_info() const;
  ::by::notificationemail::v1::SendEmailInfoResponse* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::by::notificationemail::v1::SendEmailInfoResponse* info);
  ::by::notificationemail::v1::SendEmailInfoResponse* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:by.notificationemail.v1.SendEmailResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  ::by::notificationemail::v1::SendEmailInfoResponse* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_by_2fnotificationemail_2fv1_2fby_5femail_5fnotification_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EmailStruct

// string name = 1 [json_name = "name"];
inline void EmailStruct::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& EmailStruct::name() const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.EmailStruct.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EmailStruct::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:by.notificationemail.v1.EmailStruct.name)
}
inline std::string* EmailStruct::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.EmailStruct.name)
  return _s;
}
inline const std::string& EmailStruct::_internal_name() const {
  return name_.Get();
}
inline void EmailStruct::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EmailStruct::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EmailStruct::release_name() {
  // @@protoc_insertion_point(field_release:by.notificationemail.v1.EmailStruct.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EmailStruct::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:by.notificationemail.v1.EmailStruct.name)
}

// string email = 2 [json_name = "email"];
inline void EmailStruct::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& EmailStruct::email() const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.EmailStruct.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EmailStruct::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:by.notificationemail.v1.EmailStruct.email)
}
inline std::string* EmailStruct::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.EmailStruct.email)
  return _s;
}
inline const std::string& EmailStruct::_internal_email() const {
  return email_.Get();
}
inline void EmailStruct::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EmailStruct::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EmailStruct::release_email() {
  // @@protoc_insertion_point(field_release:by.notificationemail.v1.EmailStruct.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EmailStruct::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:by.notificationemail.v1.EmailStruct.email)
}

// -------------------------------------------------------------------

// EmailData

// repeated .by.notificationemail.v1.EmailStruct to = 1 [json_name = "to"];
inline int EmailData::_internal_to_size() const {
  return to_.size();
}
inline int EmailData::to_size() const {
  return _internal_to_size();
}
inline void EmailData::clear_to() {
  to_.Clear();
}
inline ::by::notificationemail::v1::EmailStruct* EmailData::mutable_to(int index) {
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.EmailData.to)
  return to_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >*
EmailData::mutable_to() {
  // @@protoc_insertion_point(field_mutable_list:by.notificationemail.v1.EmailData.to)
  return &to_;
}
inline const ::by::notificationemail::v1::EmailStruct& EmailData::_internal_to(int index) const {
  return to_.Get(index);
}
inline const ::by::notificationemail::v1::EmailStruct& EmailData::to(int index) const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.EmailData.to)
  return _internal_to(index);
}
inline ::by::notificationemail::v1::EmailStruct* EmailData::_internal_add_to() {
  return to_.Add();
}
inline ::by::notificationemail::v1::EmailStruct* EmailData::add_to() {
  ::by::notificationemail::v1::EmailStruct* _add = _internal_add_to();
  // @@protoc_insertion_point(field_add:by.notificationemail.v1.EmailData.to)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >&
EmailData::to() const {
  // @@protoc_insertion_point(field_list:by.notificationemail.v1.EmailData.to)
  return to_;
}

// repeated .by.notificationemail.v1.EmailStruct cc = 2 [json_name = "cc"];
inline int EmailData::_internal_cc_size() const {
  return cc_.size();
}
inline int EmailData::cc_size() const {
  return _internal_cc_size();
}
inline void EmailData::clear_cc() {
  cc_.Clear();
}
inline ::by::notificationemail::v1::EmailStruct* EmailData::mutable_cc(int index) {
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.EmailData.cc)
  return cc_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >*
EmailData::mutable_cc() {
  // @@protoc_insertion_point(field_mutable_list:by.notificationemail.v1.EmailData.cc)
  return &cc_;
}
inline const ::by::notificationemail::v1::EmailStruct& EmailData::_internal_cc(int index) const {
  return cc_.Get(index);
}
inline const ::by::notificationemail::v1::EmailStruct& EmailData::cc(int index) const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.EmailData.cc)
  return _internal_cc(index);
}
inline ::by::notificationemail::v1::EmailStruct* EmailData::_internal_add_cc() {
  return cc_.Add();
}
inline ::by::notificationemail::v1::EmailStruct* EmailData::add_cc() {
  ::by::notificationemail::v1::EmailStruct* _add = _internal_add_cc();
  // @@protoc_insertion_point(field_add:by.notificationemail.v1.EmailData.cc)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >&
EmailData::cc() const {
  // @@protoc_insertion_point(field_list:by.notificationemail.v1.EmailData.cc)
  return cc_;
}

// repeated .by.notificationemail.v1.EmailStruct bbc = 3 [json_name = "bbc"];
inline int EmailData::_internal_bbc_size() const {
  return bbc_.size();
}
inline int EmailData::bbc_size() const {
  return _internal_bbc_size();
}
inline void EmailData::clear_bbc() {
  bbc_.Clear();
}
inline ::by::notificationemail::v1::EmailStruct* EmailData::mutable_bbc(int index) {
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.EmailData.bbc)
  return bbc_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >*
EmailData::mutable_bbc() {
  // @@protoc_insertion_point(field_mutable_list:by.notificationemail.v1.EmailData.bbc)
  return &bbc_;
}
inline const ::by::notificationemail::v1::EmailStruct& EmailData::_internal_bbc(int index) const {
  return bbc_.Get(index);
}
inline const ::by::notificationemail::v1::EmailStruct& EmailData::bbc(int index) const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.EmailData.bbc)
  return _internal_bbc(index);
}
inline ::by::notificationemail::v1::EmailStruct* EmailData::_internal_add_bbc() {
  return bbc_.Add();
}
inline ::by::notificationemail::v1::EmailStruct* EmailData::add_bbc() {
  ::by::notificationemail::v1::EmailStruct* _add = _internal_add_bbc();
  // @@protoc_insertion_point(field_add:by.notificationemail.v1.EmailData.bbc)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >&
EmailData::bbc() const {
  // @@protoc_insertion_point(field_list:by.notificationemail.v1.EmailData.bbc)
  return bbc_;
}

// repeated .by.notificationemail.v1.EmailStruct reply_to = 4 [json_name = "replyTo"];
inline int EmailData::_internal_reply_to_size() const {
  return reply_to_.size();
}
inline int EmailData::reply_to_size() const {
  return _internal_reply_to_size();
}
inline void EmailData::clear_reply_to() {
  reply_to_.Clear();
}
inline ::by::notificationemail::v1::EmailStruct* EmailData::mutable_reply_to(int index) {
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.EmailData.reply_to)
  return reply_to_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >*
EmailData::mutable_reply_to() {
  // @@protoc_insertion_point(field_mutable_list:by.notificationemail.v1.EmailData.reply_to)
  return &reply_to_;
}
inline const ::by::notificationemail::v1::EmailStruct& EmailData::_internal_reply_to(int index) const {
  return reply_to_.Get(index);
}
inline const ::by::notificationemail::v1::EmailStruct& EmailData::reply_to(int index) const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.EmailData.reply_to)
  return _internal_reply_to(index);
}
inline ::by::notificationemail::v1::EmailStruct* EmailData::_internal_add_reply_to() {
  return reply_to_.Add();
}
inline ::by::notificationemail::v1::EmailStruct* EmailData::add_reply_to() {
  ::by::notificationemail::v1::EmailStruct* _add = _internal_add_reply_to();
  // @@protoc_insertion_point(field_add:by.notificationemail.v1.EmailData.reply_to)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::by::notificationemail::v1::EmailStruct >&
EmailData::reply_to() const {
  // @@protoc_insertion_point(field_list:by.notificationemail.v1.EmailData.reply_to)
  return reply_to_;
}

// string subject = 5 [json_name = "subject"];
inline void EmailData::clear_subject() {
  subject_.ClearToEmpty();
}
inline const std::string& EmailData::subject() const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.EmailData.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EmailData::set_subject(ArgT0&& arg0, ArgT... args) {
 
 subject_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:by.notificationemail.v1.EmailData.subject)
}
inline std::string* EmailData::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.EmailData.subject)
  return _s;
}
inline const std::string& EmailData::_internal_subject() const {
  return subject_.Get();
}
inline void EmailData::_internal_set_subject(const std::string& value) {
  
  subject_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EmailData::_internal_mutable_subject() {
  
  return subject_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EmailData::release_subject() {
  // @@protoc_insertion_point(field_release:by.notificationemail.v1.EmailData.subject)
  return subject_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EmailData::set_allocated_subject(std::string* subject) {
  if (subject != nullptr) {
    
  } else {
    
  }
  subject_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subject,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:by.notificationemail.v1.EmailData.subject)
}

// string tag = 6 [json_name = "tag"];
inline void EmailData::clear_tag() {
  tag_.ClearToEmpty();
}
inline const std::string& EmailData::tag() const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.EmailData.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EmailData::set_tag(ArgT0&& arg0, ArgT... args) {
 
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:by.notificationemail.v1.EmailData.tag)
}
inline std::string* EmailData::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.EmailData.tag)
  return _s;
}
inline const std::string& EmailData::_internal_tag() const {
  return tag_.Get();
}
inline void EmailData::_internal_set_tag(const std::string& value) {
  
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EmailData::_internal_mutable_tag() {
  
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EmailData::release_tag() {
  // @@protoc_insertion_point(field_release:by.notificationemail.v1.EmailData.tag)
  return tag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EmailData::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:by.notificationemail.v1.EmailData.tag)
}

// string text = 7 [json_name = "text"];
inline void EmailData::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& EmailData::text() const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.EmailData.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EmailData::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:by.notificationemail.v1.EmailData.text)
}
inline std::string* EmailData::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.EmailData.text)
  return _s;
}
inline const std::string& EmailData::_internal_text() const {
  return text_.Get();
}
inline void EmailData::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EmailData::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EmailData::release_text() {
  // @@protoc_insertion_point(field_release:by.notificationemail.v1.EmailData.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EmailData::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:by.notificationemail.v1.EmailData.text)
}

// string html = 8 [json_name = "html"];
inline void EmailData::clear_html() {
  html_.ClearToEmpty();
}
inline const std::string& EmailData::html() const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.EmailData.html)
  return _internal_html();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EmailData::set_html(ArgT0&& arg0, ArgT... args) {
 
 html_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:by.notificationemail.v1.EmailData.html)
}
inline std::string* EmailData::mutable_html() {
  std::string* _s = _internal_mutable_html();
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.EmailData.html)
  return _s;
}
inline const std::string& EmailData::_internal_html() const {
  return html_.Get();
}
inline void EmailData::_internal_set_html(const std::string& value) {
  
  html_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EmailData::_internal_mutable_html() {
  
  return html_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EmailData::release_html() {
  // @@protoc_insertion_point(field_release:by.notificationemail.v1.EmailData.html)
  return html_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EmailData::set_allocated_html(std::string* html) {
  if (html != nullptr) {
    
  } else {
    
  }
  html_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), html,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:by.notificationemail.v1.EmailData.html)
}

// -------------------------------------------------------------------

// SendEmailRequest

// .by.notificationemail.v1.EmailData email_data = 1 [json_name = "emailData"];
inline bool SendEmailRequest::_internal_has_email_data() const {
  return this != internal_default_instance() && email_data_ != nullptr;
}
inline bool SendEmailRequest::has_email_data() const {
  return _internal_has_email_data();
}
inline void SendEmailRequest::clear_email_data() {
  if (GetArenaForAllocation() == nullptr && email_data_ != nullptr) {
    delete email_data_;
  }
  email_data_ = nullptr;
}
inline const ::by::notificationemail::v1::EmailData& SendEmailRequest::_internal_email_data() const {
  const ::by::notificationemail::v1::EmailData* p = email_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::by::notificationemail::v1::EmailData&>(
      ::by::notificationemail::v1::_EmailData_default_instance_);
}
inline const ::by::notificationemail::v1::EmailData& SendEmailRequest::email_data() const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.SendEmailRequest.email_data)
  return _internal_email_data();
}
inline void SendEmailRequest::unsafe_arena_set_allocated_email_data(
    ::by::notificationemail::v1::EmailData* email_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(email_data_);
  }
  email_data_ = email_data;
  if (email_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:by.notificationemail.v1.SendEmailRequest.email_data)
}
inline ::by::notificationemail::v1::EmailData* SendEmailRequest::release_email_data() {
  
  ::by::notificationemail::v1::EmailData* temp = email_data_;
  email_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::by::notificationemail::v1::EmailData* SendEmailRequest::unsafe_arena_release_email_data() {
  // @@protoc_insertion_point(field_release:by.notificationemail.v1.SendEmailRequest.email_data)
  
  ::by::notificationemail::v1::EmailData* temp = email_data_;
  email_data_ = nullptr;
  return temp;
}
inline ::by::notificationemail::v1::EmailData* SendEmailRequest::_internal_mutable_email_data() {
  
  if (email_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::by::notificationemail::v1::EmailData>(GetArenaForAllocation());
    email_data_ = p;
  }
  return email_data_;
}
inline ::by::notificationemail::v1::EmailData* SendEmailRequest::mutable_email_data() {
  ::by::notificationemail::v1::EmailData* _msg = _internal_mutable_email_data();
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.SendEmailRequest.email_data)
  return _msg;
}
inline void SendEmailRequest::set_allocated_email_data(::by::notificationemail::v1::EmailData* email_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete email_data_;
  }
  if (email_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::by::notificationemail::v1::EmailData>::GetOwningArena(email_data);
    if (message_arena != submessage_arena) {
      email_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, email_data, submessage_arena);
    }
    
  } else {
    
  }
  email_data_ = email_data;
  // @@protoc_insertion_point(field_set_allocated:by.notificationemail.v1.SendEmailRequest.email_data)
}

// -------------------------------------------------------------------

// SendEmailInfoResponse

// bool send = 1 [json_name = "send"];
inline void SendEmailInfoResponse::clear_send() {
  send_ = false;
}
inline bool SendEmailInfoResponse::_internal_send() const {
  return send_;
}
inline bool SendEmailInfoResponse::send() const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.SendEmailInfoResponse.send)
  return _internal_send();
}
inline void SendEmailInfoResponse::_internal_set_send(bool value) {
  
  send_ = value;
}
inline void SendEmailInfoResponse::set_send(bool value) {
  _internal_set_send(value);
  // @@protoc_insertion_point(field_set:by.notificationemail.v1.SendEmailInfoResponse.send)
}

// -------------------------------------------------------------------

// SendEmailResponse

// string status = 1 [json_name = "status"];
inline void SendEmailResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& SendEmailResponse::status() const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.SendEmailResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendEmailResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:by.notificationemail.v1.SendEmailResponse.status)
}
inline std::string* SendEmailResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.SendEmailResponse.status)
  return _s;
}
inline const std::string& SendEmailResponse::_internal_status() const {
  return status_.Get();
}
inline void SendEmailResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendEmailResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendEmailResponse::release_status() {
  // @@protoc_insertion_point(field_release:by.notificationemail.v1.SendEmailResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SendEmailResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:by.notificationemail.v1.SendEmailResponse.status)
}

// string message = 2 [json_name = "message"];
inline void SendEmailResponse::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& SendEmailResponse::message() const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.SendEmailResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendEmailResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:by.notificationemail.v1.SendEmailResponse.message)
}
inline std::string* SendEmailResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.SendEmailResponse.message)
  return _s;
}
inline const std::string& SendEmailResponse::_internal_message() const {
  return message_.Get();
}
inline void SendEmailResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendEmailResponse::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendEmailResponse::release_message() {
  // @@protoc_insertion_point(field_release:by.notificationemail.v1.SendEmailResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SendEmailResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:by.notificationemail.v1.SendEmailResponse.message)
}

// .by.notificationemail.v1.SendEmailInfoResponse info = 3 [json_name = "info"];
inline bool SendEmailResponse::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool SendEmailResponse::has_info() const {
  return _internal_has_info();
}
inline void SendEmailResponse::clear_info() {
  if (GetArenaForAllocation() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::by::notificationemail::v1::SendEmailInfoResponse& SendEmailResponse::_internal_info() const {
  const ::by::notificationemail::v1::SendEmailInfoResponse* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::by::notificationemail::v1::SendEmailInfoResponse&>(
      ::by::notificationemail::v1::_SendEmailInfoResponse_default_instance_);
}
inline const ::by::notificationemail::v1::SendEmailInfoResponse& SendEmailResponse::info() const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.SendEmailResponse.info)
  return _internal_info();
}
inline void SendEmailResponse::unsafe_arena_set_allocated_info(
    ::by::notificationemail::v1::SendEmailInfoResponse* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:by.notificationemail.v1.SendEmailResponse.info)
}
inline ::by::notificationemail::v1::SendEmailInfoResponse* SendEmailResponse::release_info() {
  
  ::by::notificationemail::v1::SendEmailInfoResponse* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::by::notificationemail::v1::SendEmailInfoResponse* SendEmailResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:by.notificationemail.v1.SendEmailResponse.info)
  
  ::by::notificationemail::v1::SendEmailInfoResponse* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::by::notificationemail::v1::SendEmailInfoResponse* SendEmailResponse::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::by::notificationemail::v1::SendEmailInfoResponse>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::by::notificationemail::v1::SendEmailInfoResponse* SendEmailResponse::mutable_info() {
  ::by::notificationemail::v1::SendEmailInfoResponse* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.SendEmailResponse.info)
  return _msg;
}
inline void SendEmailResponse::set_allocated_info(::by::notificationemail::v1::SendEmailInfoResponse* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::by::notificationemail::v1::SendEmailInfoResponse>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:by.notificationemail.v1.SendEmailResponse.info)
}

// string error = 4 [json_name = "error"];
inline void SendEmailResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& SendEmailResponse::error() const {
  // @@protoc_insertion_point(field_get:by.notificationemail.v1.SendEmailResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendEmailResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:by.notificationemail.v1.SendEmailResponse.error)
}
inline std::string* SendEmailResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:by.notificationemail.v1.SendEmailResponse.error)
  return _s;
}
inline const std::string& SendEmailResponse::_internal_error() const {
  return error_.Get();
}
inline void SendEmailResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendEmailResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendEmailResponse::release_error() {
  // @@protoc_insertion_point(field_release:by.notificationemail.v1.SendEmailResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SendEmailResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:by.notificationemail.v1.SendEmailResponse.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace notificationemail
}  // namespace by

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_by_2fnotificationemail_2fv1_2fby_5femail_5fnotification_2eproto
